
Эксперимент 1: Проверка корректности работы на тестовых данных
---------------------------------------------------------------
Цель:
  Убедиться, что алгоритм корректно выделяет общие подформулы и строит многоуровневое описание на простых тестовых данных.

Входные данные:

Файл classes_list.txt:
class1.txt
class2.txt
class3.txt
class4.txt
class5.txt

Файл class1.txt:
P(x1,x2)&Q(x2,x3)&R(x3)&S(x1,x3)

Файл class2.txt:
P(x1,x2)&Q(x2,x3)&Q(x3,x4)&R(x4)

Файл class3.txt:
Q(x1,x2)&R(x2)&S(x2,x3)&T(x3)

Файл class4.txt:
P(x1,x2)&S(x1,x3)&T(x3)

Файл class5.txt:
P(x1,x2)&P(x2,x3)&Q(x3,x4)&R(x4)&S(x4,x5)

Файл scene.txt:
P(a,b)
Q(b,c)
R(c)
S(a,c)
P(d,e)
Q(e,f)
Q(f,g)
R(g)
Q(h,i)
R(i)
S(i,j)
T(j)
P(k,l)
S(k,m)
T(m)
P(n,o)
P(o,p)
Q(p,q)
R(q)
S(q,r)
P(u,v)
Q(v,w)
T(w)
S(w,x)
R(x)

Результаты:
  Алгоритм построил 4 уровня: p1_i, p2_i, p3_i, p4_i
  Все подформулы классов успешно выделены и сопоставлены с фактами сцены.

Вывод:
  Алгоритм корректно работает на тестовом наборе. Структура уровней соответствует ожиданиям.

---------------------------------------------------------------

Эксперимент 2: Сравнение вычислительной сложности
---------------------------------------------------------------
Цель:
  Сравнить время выполнения и структуру вывода при построении многоуровневого и одноуровневого описания.

Условия:
  Входные данные те же, что в Эксперименте 1.

Режим A (многоуровневый):
  Время выполнения: 0.318 сек
  Построено уровней: 4
  Обнаружены повторяющиеся подформулы на p2 и p3 уровнях

Режим B (только уровень 1):
  Время выполнения: 0.143 сек
  Построен только p1 уровень, каждый класс разложен на атомарные предикаты, повторяющихся структур не выделяется

Вывод:
  Многоуровневое описание требует немного больше времени на построение, но даёт более компактное и повторно используемое представление.

---------------------------------------------------------------

Эксперимент 3: Влияние параметров фильтрации подформул
---------------------------------------------------------------
Цель:
  Оценить, как параметры фильтрации (MIN_FREQ, MAX_LITS, MAX_VARS) влияют на глубину и качество построенного описания.

Конфигурации запусков:

Режим A:
  MIN_FREQ = 1
  MAX_LITS = 10
  MAX_VARS = 10
  Время: 0.160 сек
  Уровней: 4

Режим B:
  MIN_FREQ = 2
  MAX_LITS = 10
  MAX_VARS = 10
  Время: 0.133 сек
  Уровней: 4

Режим C:
  MIN_FREQ = 3
  MAX_LITS = 10
  MAX_VARS = 10
  Время: 0.136 сек
  Уровней: 4, но почти пустые

Режим D:
  MIN_FREQ = 2
  MAX_LITS = 6
  MAX_VARS = 6
  Время: 0.141 сек
  Уровней: 4, но упрощённые формулы

Вывод:
  Повышение MIN_FREQ резко уменьшает число подходящих подформул.
  Ограничение MAX_LITS/MAX_VARS сокращает логическую сложность формул.
  Необходимо балансировать между полнотой и сжатием описания.

---------------------------------------------------------------

Эксперимент 4: Применение к распознаванию объектов
---------------------------------------------------------------
Цель:
  Проверить, способен ли алгоритм на основе многоуровневого описания распознавать объекты на сцене.

Входные данные:

Файл classes_list.txt:
class1.txt
class2.txt
class3.txt
class4.txt
class5.txt

Файл class1.txt:
P(x1,x2)&Q(x2,x3)&R(x3)&S(x1,x3)

Файл class2.txt:
P(x1,x2)&Q(x2,x3)&Q(x3,x4)&R(x4)

Файл class3.txt:
Q(x1,x2)&R(x2)&S(x2,x3)&T(x3)

Файл class4.txt:
P(x1,x2)&S(x1,x3)&T(x3)

Файл class5.txt:
P(x1,x2)&P(x2,x3)&Q(x3,x4)&R(x4)&S(x4,x5)

Файл scene.txt:
P(a,b)
Q(b,c)
R(c)
S(a,c)
P(d,e)
Q(e,f)
Q(f,g)
R(g)
Q(h,i)
R(i)
S(i,j)
T(j)
P(k,l)
S(k,m)
T(m)
P(n,o)
P(o,p)
Q(p,q)
R(q)
S(q,r)
P(u,v)
Q(v,w)
T(w)
S(w,x)
R(x)

Результаты:
  Построены уровни p1_i, p2_i, p3_i
  Распознаны объекты:
    - class1: P(a,b), Q(b,c), R(c), S(a,c)
    - class2: P(d,e), Q(e,f), Q(f,g), R(g)
    - class3: Q(h,i), R(i), S(i,j), T(j)
    - class4: P(k,l), S(k,m), T(m)
    - class5: P(n,o), P(o,p), Q(p,q), R(q), S(q,r)

Вывод:
  Алгоритм способен выявить объекты всех классов в сложной сцене. Многоуровневое представление упрощает сопоставление формул с подструктурами сцены.
